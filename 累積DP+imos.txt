#include <bits/stdc++.h>
typedef long long ll;
typedef long double ld;
const int INF=1e9,MOD=1e9+7,ohara=1e6+10;
const ll LINF=1e18;
using namespace std;

#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)
#define rrep(i,a,b) for(int i=(a);i<(b);i++)
#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)
#define all(v) (v).begin(), (v).end()
#define Size(n) (n).size()
#define Cout(x) cout<<(x)<<endl
#define Cerr(x) cerr<<(x)<<endl
#define fi first
#define se second
#define P pair<ll,ll> 
#define m_p make_pair
#define V vector<ll> 

ll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k,l[ohara],r[ohara];
ld doua;
int dy[]={1,0,-1,0};
int dx[]={0,1,0,-1};
//int dy[]={-1,0,1,-1,1,-1,0,1};
//int dx[]={-1,-1,-1,0,0,1,1,1};
string alph("abcdefghijklmnopqrstuvwxyz"),s;
bool fl;
struct edge{int to,cost;};
ll dp[4000][4000];
ll cntt=0;
ll imos[4000];

//-------------------------↓↓↓↓↓↓------------------------

int main(void){
       cin.tie(0);
    ios::sync_with_stdio(false);

    cin >> n >> m >> k;
    rep(i, m)cin >> l[i] >> r[i];

    dp[0][1] = 1;
    rrep(i, 1, k+1){
        rrep(j, 1, n+1){
            (dp[i-1][j] += dp[i-1][j-1]) %= MOD;
        }
        rep(j, n+1)imos[j] = 0;
        rep(j, m){
            tmp = dp[i-1][r[j]] - dp[i-1][l[j]-1];
            tmp %= MOD;
            (imos[l[j]] += tmp) %= MOD;
            imos[r[j]+1] -= tmp;
            (imos[r[j]+1] += MOD) %= MOD;
        }
        rrep(j, 1, n+1){
            (imos[j] += imos[j-1]) %= MOD;
            (dp[i][j] += imos[j]) %= MOD;
        }
    }
    Cout(dp[k][n] % MOD);
    return 0;
}

//////////////累積DPである区間における和を求める。l〜rにその場合の数が適用されるのでimosで差し引きすればjに対してO(1)でアクセス可能
